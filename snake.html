<!DOCTYPE html><html class="d-flex align-items-center flex-column justify-content-center h-100 bg-light"><head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="preconnect" href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous"> <style> :root { --bs-font-sans-serif: 'Ubuntu Mono', monospace; --color-view-border: #606060;}header { max-width: 20rem;}#view { visibility: hidden; border: 6px dotted var(--color-view-border); border-radius: 12px;}.small-caps { font-size: inherit; font-variant: small-caps; text-decoration: underline;}#play { width: 6rem; height: 6rem; margin-left: 0.8rem;}#message { font-size: 1.25rem; color: var(--color-view-border);}.arrow-buttons { padding-left: 5rem;}.arrow-buttons button { width: 8rem; height: 4rem; margin: 0.2rem 0.3rem;}#up { border-top-left-radius: 2.6rem; border-top-right-radius: 2.6rem; width: 9rem;}#down { border-bottom-left-radius: 2.6rem; border-bottom-right-radius: 2.6rem; width: 9rem;}#left { border-top-left-radius: 1.6rem; border-bottom-left-radius: 1.6rem;}#right { border-top-right-radius: 1.6rem; border-bottom-right-radius: 1.6rem;}.btn { font-size: 1.25rem;} </style></head><body class="d-flex align-items-center flex-column justify-content-center h-100 bg-light"> <header> <h1 class="text-center">Snake</h1> <h6 class="text-start">Press <span class="small-caps">play</span> or <span class="small-caps">space</span> to start, <span class="small-caps">esc</span> to quit. Use arrow keys or the buttons below.</h6> </header> <canvas id="view" class="mt-5"></canvas> <div class="d-flex flex-row justify-content-between align-items-center w-100 mt-5"> <button type="button" class="btn btn-warning btn-danger" id="play" value="play">play</button> <span id="message"></span> </div> <div class="arrow-buttons"> <div class="d-flex flex-row justify-content-center"> <button type="button" class="btn btn-dark" id="up">up</button> </div> <div class="d-flex flex-row justify-content-center"> <button type="button" class="btn btn-dark" id="left">left</button> <button type="button" class="btn btn-dark" id="right">right</button> </div> <div class="d-flex flex-row justify-content-center"> <button type="button" class="btn btn-dark" id="down">down</button> </div> </div> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script> <script> const U = 18;const FIELD_WIDTH = 17;const FIELD_HEIGHT = 17;const FIELD_WIDTH_PX = FIELD_WIDTH * U;const FIELD_HEIGHT_PX = FIELD_HEIGHT * U;const START_X = Math.floor(FIELD_WIDTH / 2);const START_Y = Math.floor(FIELD_HEIGHT / 2);const DIRECTION = { UP: { x: 0, y: -1 }, DOWN: { x: 0, y: 1 }, LEFT: { x: -1, y: 0 }, RIGHT: { x: 1, y: 0 }, NONE: { x: 0, y: 0 },};const FRAMERATE_0 = 640;const FRAMERATE_1 = 550;const FRAMERATE_2 = 470;const FRAMERATE_3 = 380;const FRAMERATE_4 = 290;const FRAMERATE_5 = 230;const COLOR_SNAKE_BODY = '#239b56';const COLOR_SNAKE_HEAD = '#196f3d';const COLOR_FOOD = '#d22d3b';const COLOR_BLANK = '#f0f0f1';const COLOR_FOG = 'rgba(88, 64, 70, 0.5)'; </script> <script> class Node { constructor({ x, y, prev = null, next = null }) { this.x = x; this.y = y; this.prev = prev; this.next = next; /* this.id = Node.count++; */ } /* static count = 0; */ moveTo({ x, y }) { this.x = x; this.y = y; }}class Snake { constructor() { this.head = new Node({ x: START_X, y: START_Y }); this.tail = this.head; this.length = 1; this.direction = Snake.getRandomDirection(); this.lock = false; } index(i = 0) { let node = this.head; let index = 0; for (; node && index < i; index++) { node = node.next; } return index == i ? node : null; } turn(direction) { if (this.lock) return; switch (this.direction) { case DIRECTION.UP: case DIRECTION.DOWN: if (direction == DIRECTION.LEFT || direction == DIRECTION.RIGHT) { this.direction = direction; this.lock = true; } return; case DIRECTION.LEFT: case DIRECTION.RIGHT: if (direction == DIRECTION.UP || direction == DIRECTION.DOWN) { this.direction = direction; this.lock = true; } return; } } walk(grow) { if (grow) { const newHead = new Node(Snake.getNextPosition(this.head, this.direction)); this.head.prev = newHead; newHead.next = this.head; this.head = newHead; this.length += 1; this.lock = false; return; } const newHead = this.tail; if (this.length > 1) { this.tail = newHead.prev; this.tail.next = null; this.head.prev = newHead; newHead.prev = null; newHead.next = this.head; } /* Reassign this.head only after moving newHead to allow accessing the old head's coordinates */ newHead.moveTo(Snake.getNextPosition(this.head, this.direction)); this.head = newHead; this.lock = false; } find(x, y, i) { let node = this.index(i); while (node != null) { if (node.x == x && node.y == y) { return true; } node = node.next; } return false; } [Symbol.iterator]() { let node = { prev: this.tail }; const next = () => { node = node.prev; return { value: { x: (node || {}).x, y: (node || {}).y }, done: node == null }; }; return { next }; } static getNextPosition(node, step) { return { x: node.x + step.x, y: node.y + step.y }; } static getRandomDirection() { switch (Math.floor(Math.random() * 4)) { case 0: return DIRECTION.UP; case 1: return DIRECTION.DOWN; case 2: return DIRECTION.LEFT; case 3: return DIRECTION.RIGHT; } }}class Food { constructor(snake) { let x = Math.floor(Math.random() * FIELD_WIDTH), y = Math.floor(Math.random() * FIELD_HEIGHT); while (snake.find(x, y, 0)) { x = Math.floor(Math.random() * FIELD_WIDTH); y = Math.floor(Math.random() * FIELD_HEIGHT); } this.x = x; this.y = y; }}class Game { constructor() { this.snake = new Snake(); this.food = new Food(this.snake); this.view = view; this.noFood = false; this.controller = new Controller(); this.killed = false; } get score() { return this.snake.length - 1; } snakeIsAlive() { const { x, y } = this.snake.head; if ( x >= FIELD_WIDTH || x < 0 || y >= FIELD_HEIGHT || y < 0 ) return false; if (this.snake.find(x, y, 1)) return false; return true; } foodIsEaten() { const nextPosition = Snake.getNextPosition(this.snake.head, this.snake.direction); return this.noFood = nextPosition.x == this.food.x && nextPosition.y == this.food.y; } checkAndReplaceFood() { if (this.noFood) { this.food = new Food(this.snake); } } getHandlers() { return { up: () => this.snake.turn(DIRECTION.UP), down: () => this.snake.turn(DIRECTION.DOWN), left: () => this.snake.turn(DIRECTION.LEFT), right: () => this.snake.turn(DIRECTION.RIGHT), kill: () => this.killed = true }; } getFramerate() { if (this.snake.length < 4) return FRAMERATE_0; if (this.snake.length < 8) return FRAMERATE_1; if (this.snake.length < 12) return FRAMERATE_2; if (this.snake.length < 18) return FRAMERATE_3; if (this.snake.length < 28) return FRAMERATE_4; return FRAMERATE_5; } setHandlers() { this.controller.set(this.getHandlers()); } removeHandlers() { this.controller.removeHandlers(); } async start() { /* The loop must follow this order: clear -> render -> sleep -> update -> check alive There should be no rendering after check alive returns false. */ while (this.snakeIsAlive()) { this.view.clear(); this.view.render(this); await sleep(this.getFramerate()); this.snake.walk(this.foodIsEaten()); this.checkAndReplaceFood(); if (this.killed) break; } this.view.finalRender(this); }}function sleep(time) { return new Promise(resolve => setTimeout(resolve, time));} function bounded(x, y) { return x >= 0 && x < FIELD_WIDTH && y >= 0 && y < FIELD_HEIGHT;} </script> <script> let highScore = 0;class View { constructor() { const view = document.getElementById('view'); /* canvas.width is different from canvas.style.width. The former sets the pixals; the latter scales the element. Don't use canvas.style.width as it would blur the image. */ view.width = FIELD_WIDTH_PX; view.height = FIELD_HEIGHT_PX; view.style.visibility = 'visible'; this.ctx = view.getContext('2d'); this.clear(); this.message = document.getElementById('message'); } clear() { this.ctx.fillStyle = COLOR_BLANK; this.ctx.fillRect(0, 0, FIELD_WIDTH_PX, FIELD_HEIGHT_PX); } render(game) { const { snake, food } = game; const ctx = this.ctx; ctx.fillStyle = COLOR_FOOD; ctx.fillRect(food.x * U + 1, food.y * U + 1, U - 2, U - 2); ctx.fillStyle = COLOR_SNAKE_BODY; for (const { x, y } of snake) { ctx.fillRect(x * U + 1, y * U + 1, U - 2, U - 2); } const { x, y } = snake.head; ctx.fillStyle = COLOR_SNAKE_HEAD; ctx.fillRect(x * U + 1, y * U + 1, U - 2, U - 2); this.message.innerText = `Score: ${game.score}`; } finalRender(game) { this.ctx.fillStyle = COLOR_FOG; this.ctx.fillRect(0, 0, FIELD_WIDTH_PX, FIELD_HEIGHT_PX); if (game.score > highScore) highScore = game.score; this.message.innerText = `High Score: ${highScore}\nLast Score: ${game.score}`; }}const view = new View();/*function consoleRender(game) { const { snake, food } = game; const field = new Array(FIELD_HEIGHT); for (let i = 0; i < FIELD_WIDTH; i++) { field[i] = new Array(FIELD_WIDTH).fill('-'); } field[food.y][food.x] = 'o'; for (const { x, y } of snake) { if (bounded(x, y)) field[y][x] = String('U'); } const { x, y } = snake.head; if (bounded(x, y)) field[y][x] = String('O'); let output = ''; for (let i = 0; i < FIELD_HEIGHT; i++) { for (let j = 0; j < FIELD_WIDTH; j++) { output += field[i][j]; } output += ('\n'); } output += `Score: ${game.score}\n\n`; console.log(output);}*/ </script> <script> class Controller { constructor() { this.upBtn = document.getElementById('up'); this.downBtn = document.getElementById('down'); this.leftBtn = document.getElementById('left'); this.rightBtn = document.getElementById('right'); } set({ up, down, left, right, kill }) { this.upBtn.addEventListener('click', _ => { up(); this.upBtn.blur(); }); this.downBtn.addEventListener('click', _ => { down(); this.downBtn.blur(); }); this.leftBtn.addEventListener('click', _ => { left(); this.leftBtn.blur(); }); this.rightBtn.addEventListener('click', _ => { right(); this.rightBtn.blur(); }); const handleKeydown = ev => { switch (ev.keyCode) { case 37: return left(); case 38: return up(); case 39: return right(); case 40: return down(); case 27: return kill(); } }; document.addEventListener('keydown', handleKeydown); this.up = up; this.down = down; this.left = left; this.right = right; this.kill = kill; this.handleKeydown = handleKeydown; } removeHandlers() { document.removeEventListener('keydown', this.handleKeydown); this.upBtn.removeEventListener('click', this.up); this.downBtn.removeEventListener('click', this.down); this.leftBtn.removeEventListener('click', this.left); this.rightBtn.removeEventListener('click', this.right); }} </script> <script> function main() { const play = async () => { const game = new Game(); game.setHandlers(); togglePlay(game); await game.start(); game.removeHandlers(); togglePlay(game); }; const handleClick = () => { /* Must unfocus playBtn. See comment below */ playBtn.blur(); play(); }; const handleSpaceBar = ev => { if (ev.keyCode != 32) return; play(); }; const togglePlay = game => { /* Space Bar keydown will trigger mouse click when playBtn is focused. Must blur playBtn before adding game.controller.kill */ playBtn.blur(); if (playBtn.value == 'play') { document.removeEventListener('keydown', handleSpaceBar); playBtn.removeEventListener('click', handleClick); playBtn.addEventListener('click', game.controller.kill); playBtn.value = playBtn.textContent = 'quit'; } else { playBtn.removeEventListener('click', game.controller.kill); playBtn.addEventListener('click', handleClick); playBtn.value = playBtn.textContent = 'play'; document.addEventListener('keydown', handleSpaceBar); } playBtn.classList.toggle('btn-danger') }; const playBtn = document.getElementById('play'); document.addEventListener('keydown', handleSpaceBar); playBtn.addEventListener('click', handleClick);}main(); </script></body></html>