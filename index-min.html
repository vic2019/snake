<!DOCTYPE html><html class="d-flex align-items-center flex-column justify-content-center h-100 bg-light"><head><title>Snake</title><meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="preconnect" href="https://fonts.gstatic.com"> <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap" rel="stylesheet"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous"> <style> :root { --bs-font-sans-serif: 'Ubuntu Mono', monospace; --color-view-border: #606060;}header { max-width: 20rem;}#view { visibility: hidden; border: 6px dotted var(--color-view-border); border-radius: 12px;}.small-caps { font-size: inherit; font-variant: small-caps; text-decoration: underline;}#play { width: 6rem; height: 6rem; margin-left: 0.8rem;}#message { font-size: 1.25rem; color: var(--color-view-border);}.arrow-buttons { padding-left: 5rem;}.arrow-buttons button { width: 8rem; height: 3.8rem; margin: 0.2rem 0.3rem;}#up { border-top-left-radius: 2.6rem; border-top-right-radius: 2.6rem; width: 9rem;}#down { border-bottom-left-radius: 2.6rem; border-bottom-right-radius: 2.6rem; width: 9rem;}#left { border-top-left-radius: 1.6rem; border-bottom-left-radius: 1.6rem;}#right { border-top-right-radius: 1.6rem; border-bottom-right-radius: 1.6rem;}.btn { font-size: 1.25rem;} </style></head><body class="d-flex align-items-center flex-column justify-content-center h-100 bg-light"> <header> <h1 class="text-center">Snake</h1> <h6 class="text-start">Press <span class="small-caps">play</span> or <span class="small-caps">space</span> to start, <span class="small-caps">esc</span> to quit. Use arrow keys or the buttons below.</h6> </header> <canvas id="view" class="mt-2"></canvas> <div class="d-flex flex-row justify-content-between align-items-center w-100 mt-4"> <button type="button" class="btn btn-warning btn-danger" id="play" value="play">play</button> <span id="message"></span> </div> <div class="arrow-buttons"> <div class="d-flex flex-row justify-content-center"> <button type="button" class="btn btn-dark" id="up">up</button> </div> <div class="d-flex flex-row justify-content-center"> <button type="button" class="btn btn-dark" id="left">left</button> <button type="button" class="btn btn-dark" id="right">right</button> </div> <div class="d-flex flex-row justify-content-center"> <button type="button" class="btn btn-dark" id="down">down</button> </div> </div> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script> <script> const U = 17;const FIELD_WIDTH = 17;const FIELD_HEIGHT = 17;const FIELD_WIDTH_PX = FIELD_WIDTH * U;const FIELD_HEIGHT_PX = FIELD_HEIGHT * U;const START_X = Math.floor(FIELD_WIDTH / 2);const START_Y = Math.floor(FIELD_HEIGHT / 2);const DIRECTION = { UP: { x: 0, y: -1 }, DOWN: { x: 0, y: 1 }, LEFT: { x: -1, y: 0 }, RIGHT: { x: 1, y: 0 }, NONE: { x: 0, y: 0 },};const FRAMERATE_0 = 600;const FRAMERATE_1 = 530;const FRAMERATE_2 = 450;const FRAMERATE_3 = 370;const FRAMERATE_4 = 300;const FRAMERATE_5 = 250;const COLOR_SNAKE_BODY = '#239b56';const COLOR_SNAKE_HEAD = '#196f3d';const COLOR_FOOD = '#d22d3b';const COLOR_BLANK = '#f0f0f1';const COLOR_FOG = 'rgba(88, 64, 70, 0.5)';class Node { constructor({ x, y, prev = null, next = null }) { this.x = x; this.y = y; this.prev = prev; this.next = next; /* this.id = Node.count++; */ } /* static count = 0; */ moveTo({ x, y }) { this.x = x; this.y = y; }}class Snake { constructor() { this.head = new Node({ x: START_X, y: START_Y }); this.tail = this.head; this.length = 1; this.direction = Snake.getRandomDirection(); this.turnLock = false; } turn(direction) { if (this.turnLock) return; switch (this.direction) { case DIRECTION.UP: case DIRECTION.DOWN: if (direction == DIRECTION.LEFT || direction == DIRECTION.RIGHT) { this.direction = direction; this.turnLock = true; } return; case DIRECTION.LEFT: case DIRECTION.RIGHT: if (direction == DIRECTION.UP || direction == DIRECTION.DOWN) { this.direction = direction; this.turnLock = true; } return; } } walk(grow) { if (grow) { const newHead = new Node(this.getNextPosition()); this.head.prev = newHead; newHead.next = this.head; this.head = newHead; this.length += 1; this.turnLock = false; return; } const newHead = this.tail; if (this.length > 1) { this.tail = newHead.prev; this.tail.next = null; this.head.prev = newHead; newHead.prev = null; newHead.next = this.head; } /* Reassign this.head only after moving newHead to allow accessing the old head's coordinates */ newHead.moveTo(this.getNextPosition()); this.head = newHead; this.turnLock = false; } find(x, y) { let node = this.head; while (node != null) { if (node.x == x && node.y == y) { return node; } node = node.next; } return null; } willDie() { const { x, y } = this.getNextPosition(); if (!bounded(x, y)) return true; const node = this.find(x, y); if (node && node != this.tail) return true; return false; } getNextPosition() { return { x: this.head.x + this.direction.x, y: this.head.y + this.direction.y }; } static getRandomDirection() { switch (Math.floor(Math.random() * 4)) { case 0: return DIRECTION.UP; case 1: return DIRECTION.DOWN; case 2: return DIRECTION.LEFT; case 3: return DIRECTION.RIGHT; } } [Symbol.iterator]() { let node = { prev: this.tail }; const next = () => { node = node.prev; return { value: { x: (node || {}).x, y: (node || {}).y }, done: node == null }; }; return { next }; }}class Food { constructor(snake) { let x = Math.floor(Math.random() * FIELD_WIDTH), y = Math.floor(Math.random() * FIELD_HEIGHT); while (snake.find(x, y)) { x = Math.floor(Math.random() * FIELD_WIDTH); y = Math.floor(Math.random() * FIELD_HEIGHT); } this.x = x; this.y = y; }}class Game { constructor() { this.snake = new Snake(); this.food = new Food(this.snake); this.view = view; this.noFood = false; this.controller = new Controller(); this.killed = false; } get score() { return this.snake.length - 1; } foodIsEaten() { const { x, y } = this.snake.getNextPosition(); return this.noFood = x == this.food.x && y == this.food.y; } checkAndReplaceFood() { if (this.noFood) { this.food = new Food(this.snake); } } getHandlers() { return { up: () => this.snake.turn(DIRECTION.UP), down: () => this.snake.turn(DIRECTION.DOWN), left: () => this.snake.turn(DIRECTION.LEFT), right: () => this.snake.turn(DIRECTION.RIGHT), kill: () => this.killed = true }; } getFramerate() { if (this.snake.length < 3) return FRAMERATE_0; if (this.snake.length < 7) return FRAMERATE_1; if (this.snake.length < 11) return FRAMERATE_2; if (this.snake.length < 19) return FRAMERATE_3; if (this.snake.length < 32) return FRAMERATE_4; return FRAMERATE_5; } setHandlers() { this.controller.set(this.getHandlers()); } removeHandlers() { this.controller.removeHandlers(); } async start() { /* The loop must follow this order: clear -> render -> sleep -> check if will die after next update -> update Do not render if snake will die after next update. */ while (true) { this.view.clear(); this.view.render(this); await sleep(this.getFramerate()); if (this.killed || this.snake.willDie()) { this.view.finalRender(this); break; } this.snake.walk(this.foodIsEaten()); this.checkAndReplaceFood(); } }}function sleep(time) { return new Promise(resolve => setTimeout(resolve, time));} function bounded(x, y) { return x >= 0 && x < FIELD_WIDTH && y >= 0 && y < FIELD_HEIGHT;}let highScore = 0;class View { constructor() { const view = document.getElementById('view'); /* canvas.width is different from canvas.style.width. The former sets the pixals; the latter scales the element. Don't use canvas.style.width as it would blur the image. */ view.width = FIELD_WIDTH_PX; view.height = FIELD_HEIGHT_PX; view.style.visibility = 'visible'; this.ctx = view.getContext('2d'); this.clear(); this.message = document.getElementById('message'); } clear() { this.ctx.fillStyle = COLOR_BLANK; this.ctx.fillRect(0, 0, FIELD_WIDTH_PX, FIELD_HEIGHT_PX); } render(game) { const { snake, food } = game; const ctx = this.ctx; ctx.fillStyle = COLOR_FOOD; ctx.fillRect(food.x * U + 1, food.y * U + 1, U - 2, U - 2); ctx.fillStyle = COLOR_SNAKE_BODY; for (const { x, y } of snake) { ctx.fillRect(x * U + 1, y * U + 1, U - 2, U - 2); } const { x, y } = snake.head; ctx.fillStyle = COLOR_SNAKE_HEAD; ctx.fillRect(x * U + 1, y * U + 1, U - 2, U - 2); this.message.innerText = `Score: ${game.score}`; } finalRender(game) { this.ctx.fillStyle = COLOR_FOG; this.ctx.fillRect(0, 0, FIELD_WIDTH_PX, FIELD_HEIGHT_PX); if (game.score > highScore) highScore = game.score; this.message.innerText = `High Score: ${highScore}\nLast Score: ${game.score}`; }}const view = new View();class Controller { constructor() { this.upBtn = document.getElementById('up'); this.downBtn = document.getElementById('down'); this.leftBtn = document.getElementById('left'); this.rightBtn = document.getElementById('right'); } set({ up, down, left, right, kill }) { this.upBtn.addEventListener('click', _ => { up(); this.upBtn.blur(); }); this.downBtn.addEventListener('click', _ => { down(); this.downBtn.blur(); }); this.leftBtn.addEventListener('click', _ => { left(); this.leftBtn.blur(); }); this.rightBtn.addEventListener('click', _ => { right(); this.rightBtn.blur(); }); const handleKeydown = ev => { switch (ev.keyCode) { case 37: return left(); case 38: return up(); case 39: return right(); case 40: return down(); case 27: return kill(); } }; document.addEventListener('keydown', handleKeydown); this.up = up; this.down = down; this.left = left; this.right = right; this.kill = kill; this.handleKeydown = handleKeydown; } removeHandlers() { document.removeEventListener('keydown', this.handleKeydown); this.upBtn.removeEventListener('click', this.up); this.downBtn.removeEventListener('click', this.down); this.leftBtn.removeEventListener('click', this.left); this.rightBtn.removeEventListener('click', this.right); }}function main() { const play = async () => { const game = new Game(); game.setHandlers(); togglePlay(game); await game.start(); game.removeHandlers(); togglePlay(game); }; const handleClick = () => { /* Must unfocus playBtn. See comment below */ playBtn.blur(); play(); }; const handleSpaceBar = ev => { if (ev.keyCode != 32) return; play(); }; const togglePlay = game => { /* Space Bar keydown will trigger mouse click when playBtn is focused. Must blur playBtn before adding game.controller.kill */ playBtn.blur(); if (playBtn.value == 'play') { document.removeEventListener('keydown', handleSpaceBar); playBtn.removeEventListener('click', handleClick); playBtn.addEventListener('click', game.controller.kill); playBtn.value = playBtn.textContent = 'quit'; } else { playBtn.removeEventListener('click', game.controller.kill); playBtn.addEventListener('click', handleClick); playBtn.value = playBtn.textContent = 'play'; document.addEventListener('keydown', handleSpaceBar); } playBtn.classList.toggle('btn-danger') }; const playBtn = document.getElementById('play'); document.addEventListener('keydown', handleSpaceBar); playBtn.addEventListener('click', handleClick);}main(); </script></body></html>